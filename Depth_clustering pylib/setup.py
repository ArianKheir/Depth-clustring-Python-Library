#!/usr/bin/env python3
# Import necessary modules for the build process.

import os
import subprocess
from pathlib import Path # Modern, object-oriented way to handle filesystem paths.
from pybind11.setup_helpers import Pybind11Extension, build_ext # Helpers for building a pybind11 C++ extension.
from setuptools import setup # The core of Python package building.

# --- Project Paths ---
# Get the directory where this setup.py script is located.
project_root = Path(__file__).parent
# Define the path to the C++ source code directory.
src_dir      = project_root / "src"

# ---------- 1.  Source Files ----------
# This section programmatically gathers all the necessary C++ source files (.cpp)
# for the extension, while carefully excluding files related to Qt and ROS.

# Define the primary file that contains the pybind11 bindings. This is the "entry point"
# that exposes the C++ code to Python.

binder = "src/python_bindings.cpp"
# Create a list of all C++ source files to be compiled
cpp_sources = [binder] + [  # Start the list with the main binder file.
    # Convert the Path object to a string relative to the project's root directory.
    # This is the format required by setuptools.
    str(p.relative_to(project_root))
    # Recursively search for all files ending with .cpp inside the 'src' directory.
    for p in src_dir.rglob("*.cpp")
    # Apply a series of filters to exclude unwanted files:
    # 1. Don't include the binder file again, as it's already in the list.
    if str(p.relative_to(project_root)) != binder and
        # 2. Exclude any files located within the 'src/qt' directory.
       not p.is_relative_to(src_dir / "qt") and
       # 3. Exclude any files located within the 'src/ros_bridge' directory.
       not p.is_relative_to(src_dir / "ros_bridge") and
       # 4. Explicitly drop the main C++ executable entry point and the Qt visualizer.
       p.name not in {"main.cpp",
                      "visualizer.cpp"} and  
       # 5. Exclude files generated by the Qt UI compiler (uic).               
       "ui_" not in p.name and
       # 6. Exclude files generated by the Qt Meta-Object Compiler (moc).
       "moc_" not in p.name
]

# ---------- 2.  Include Directories ----------
# This list tells the compiler where to look for header files (.h, .hpp)
# that are included by the C++ source files.
include_dirs = [
    # Include the project's own source directory for its internal headers.
    str(src_dir),
    # Paths to system-installed dependencies. These are standard locations on Linux.
    "/usr/include/eigen3",      # For the Eigen linear algebra library.
    "/usr/include/opencv4",     # For the OpenCV computer vision library.
    "/usr/include/pcl-1.14",    # For the Point Cloud Library.
    "/usr/include/boost",       # For the Boost C++ libraries.
]

# ---------- 3.  Libraries (Qt / QGLViewer / ROS removed) ----------
# This list tells the linker which pre-compiled libraries to link against.
# The build system will automatically prepend "lib" and append ".so" or ".a"
# (e.g., "opencv_core" becomes "libopencv_core.so").
libraries = [
    # OpenCV libraries for core functionality, image processing, codecs, and UI.
    "opencv_core", "opencv_imgproc", "opencv_imgcodecs", "opencv_highgui",
    # Point Cloud Library modules.
    "pcl_common", "pcl_io", "pcl_kdtree", "pcl_search", "pcl_segmentation",
    # Boost C++ libraries.
    "boost_system", "boost_filesystem", "boost_regex", "boost_program_options",
]

# ---------- 4.  Compile / Link Flags ----------
# These are arguments passed directly to the C++ compiler.
extra_compile_args = [
    "-std=c++14",   # Enforce the C++14 standard.
    "-O2",          # A standard optimization level for release builds.
    "-fPIC",        # Generate Position-Independent Code, required for shared libraries (.so).
]

# These are preprocessor macros defined at compile time, equivalent to using #define
# in the C++ code. They are used for conditional compilation.
define_macros = [
    # Define a macro to signal that ROS features should be compiled out.
    ("ROS_NOT_AVAILABLE", "1"),   
    # Define a macro to signal that PCL helper functions should be compiled in.
    ("PCL_FOUND", "1"),           
]

# ---------- 5.  Extension Module ----------
# This defines the actual Python extension module to be built.
ext_modules = [
    Pybind11Extension(
        # The full, importable name of the module in Python.
        # e.g., `from depth_clustering._depth_clustering import ...`
        "depth_clustering._depth_clustering",
        # The list of C++ source files to compile for this extension.
        sources=cpp_sources,
        # The list of directories to search for header files.
        include_dirs=include_dirs,
        # The list of libraries to link against.
        libraries=libraries,
        # A list of directories to search for the libraries (if not in standard paths).
        library_dirs=[],
        # The preprocessor macros to define during compilation.
        define_macros=define_macros,
        # A pybind11 helper to set the C++ standard.
        cxx_std=14,
        # Pass the extra compiler arguments defined earlier.
        extra_compile_args=extra_compile_args,
    )
]


# ---------- 6.  Package Metadata ----------
# The main call to setuptools' setup function, which configures the entire package.
setup(
    # The name of the package as it will appear on PyPI.
    name="depth_clustering",
    # The version of the package
    version="1.0.0",
    # Author information.
    author="Depth Clustering Team + Arian Kheriandish (AISL)",
    # A short description of the package.
    description="Python wrapper for depth clustering library (no Qt / no ROS)",
    # List of Python packages to include. setuptools will look for an `__init__.py`
    # in the 'depth_clustering' directory.
    packages=["depth_clustering"],
    # A mapping from package names to the directories they are located in.
    package_dir={"depth_clustering": "depth_clustering"},
    # The list of C/C++ extensions to build.
    ext_modules=ext_modules,
    # This tells setuptools to use the custom `build_ext` command from pybind11,
    # which knows how to correctly compile the C++ extension.
    cmdclass={"build_ext": build_ext},
    # C extensions cannot be run from a zip file, so this must be False.
    zip_safe=False,
    # Specify the minimum required Python version.
    python_requires=">=3.7",
)